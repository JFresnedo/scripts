#!/usr/bin/python3 -u

import os
import sys
import pathlib
import argparse
import glob
import sqlite3 as sql
from pprint import pprint
from Bio import SeqIO
from collections import defaultdict
from operator import itemgetter

class OldPart():
    def __init__(self, oldname, oldstart, oldend, newname, newstart, newend, strand, parttype, comment=""):
        self.oldname = oldname
        self.oldstart = int(oldstart)
        self.oldend = int(oldend)
        self.newname = newname
        self.newstart = int(newstart)
        self.newend = int(newend)
        self.strand = int(strand)
        self.parttype = parttype
        self.comment = comment

    @property
    def length(self):
        return self.oldend - self.oldstart + 1
    
    def __repr__(self):
        return '{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}'.format(self.oldname, self.oldstart, self.oldend, self.newname, self.newstart, self.newend, self.strand, self.parttype)

class Comment:
    def __init__(self, start, end, slice_start, slice_end):
        self.start = start
        self.end = end
        self.slice_start = slice_start
        self.slice_end = slice_end

    def __repr__(self):
        return '{}\t{}\t{}\t{}'.format(self.start, self.end, self.slice_start, self.slice_end)

class MapPart:
    def __init__(self, scaffold, start, end, length, chromosome, cm, comment=""):
        self.scaffold = scaffold
        self.start = start
        self.end = end
        self.length = length
        self.chromosome =chromosome
        self.cm = cm
        self.comment = comment
    
    def __repr__(self):
        return '{}:{}-{} {}bp {} {}'.format(self.scaffold, self.start, self.end, self.length, self.chromosome, self.cm)


class MapScaffold:
    def __init__(self):
        self.mapparts = []
    
    def append(self, scaffold, start, end, length, chromosome, cm):
        self.mapparts.append(MapPart(scaffold, start, end, length, chromosome, cm))


def load_genome(mergedgenome):
    genome = defaultdict(list)
    try:
        with open(mergedgenome, 'r') as g:
            for line in g:
                oldname, oldstart, oldend, newname, newstart, newend, strand, typename = line.rstrip().split('\t')
                genome[oldname].append(OldPart(oldname, oldstart, oldend, newname, newstart, newend, strand, typename))
    except IOError:
        print("Failed to load genome file {}".format(mergedgenome))
        sys.exit()
    
    return genome

def load_linkage_map(database, errorarg, genome):
    conn_in, ci = open_input_database(database)
    
    errors = load_errors(errorarg)

    linkage_map = {}
    for chromosome, cm, scaffold, start, end, length, *args in ci.execute('select * from scaffold_map order by scaffold, start'):

        if scaffold in errors and start in errors[scaffold]:
            chromosome = 0
            cm = -1

        if not scaffold in linkage_map:
            linkage_map[scaffold] = MapScaffold()

        linkage_map[scaffold].append(scaffold, start, end, length, chromosome, cm)
    
    for scaffold in genome:
        if scaffold not in linkage_map:
            linkage_map[scaffold] = MapScaffold()
            for part in genome[scaffold]:
                linkage_map[scaffold].append(scaffold, part.oldstart, part.oldend, part.length, 0, -1)

    return linkage_map

def open_input_database(database):
    try:
        if not os.path.exists(database):
            raise IOError
        conn = sql.connect(database)
        cursor = conn.cursor()
        return conn, cursor
    except IOError:
        print("Can't open database {}".format(database))
        sys.exit(1)
    except sql.Error:
        print("SQL error")
        sys.exit(1)


def load_errors(errorarg):
    errors = defaultdict(lambda:defaultdict(int))
    if not errorarg:
        return errors

    try:
        if not os.path.isfile(errorarg):
            raise IOError
        with open(errorarg, 'r') as e:
            for line in e:
                scaffold, start = line.rstrip().split('\t')
                start = int(start)
                errors[scaffold][start] = 0

        return errors

    except IOError:
        print("Can't open error file {}".format(errorarg))
        sys.exit(1)

def load_gff(gff):
    genes = defaultdict(list)
    try:
        with open(gff) as g:
            for line in g:
                if line.startswith('#'):
                    continue
                f = line.rstrip().split('\t')
                scaffold, source, featuretype, start, end, score, strand, phase, attributes = f
                if featuretype == 'gene':
                    genes[scaffold].append((int(start), int(end)))
    except IOError:
        print("Failed to load GFF file {}".format(gff))
    
    return genes

def open_output_database(output):
    try:
        conn = sql.connect(output)
        db = conn.cursor()
        db.execute('drop table if exists scaffold_map')
        db.execute('''create table scaffold_map
                     (chromosome integer, cm real, scaffold text, start integer, end integer, length integer, type text, comments text)''')

        cursor = conn.cursor()
        return conn, cursor
    except sql.Error as sqle:
        print(sqle)
        sys.exit(1)


def get_parts(scaffold, start, end, genome):

    parts = []
    haps = []
    for part in genome[scaffold]:
        if part.oldstart > end or part.oldend < start:
            continue
        slice_start = max(part.oldstart, start)
        slice_end = min(part.oldend, end)
        slice_length = slice_end - slice_start + 1
        
        comment = '{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}'.format(part.oldname, part.oldstart, part.oldend, start, end, slice_start, slice_end, part.strand)
        start_offset = slice_start - part.oldstart
        end_offset = part.oldend - slice_end
        if part.strand == 1 or part.strand == 0:
            newstart = part.newstart + start_offset
            newend = part.newend - end_offset
        elif part.strand == -1:
            newstart = part.newstart + end_offset
            newend = part.newend - start_offset
        newpart = Part(part.newname, newstart, newend, part.oldname, part.oldstart, part.oldend, part.strand, part.parttype, Comment(start, end, slice_start, slice_end))
        if part.parttype == 'haplotype':
            haps.append(newpart)
        else:
            parts.append(newpart)
    return parts, haps

def write_new_map(linkage_map, genome, prefix, output):
    conn_out, co = open_output_database(output)
    new_map = []

    for scaffold in linkage_map:
        for part in linkage_map[scaffold].mapparts:
            new_parts, haps = get_parts(scaffold, part.start, part.end, genome)
        
            for np in new_parts:
                new_map.append([part.chromosome, part.cm] + np)

    new_map.sort(key=lambda x: (x.oldname, x.oldstart))
    fill_map(new_map)

    for mp in new_map:
        co.execute('insert into scaffold_map values (?,?,?,?,?,?,?,?)', mp)

    conn_out.commit()
    conn_out.close()

def fill_map(mapparts):
    i = 0
    j = 1

    while i < len(mapparts) - 1:
        mpi = mapparts[i]
    
        if mpi[0] == 0 or mpi[1] == -1:
            i += 1
            continue
        
        parts = []
        j = i+1
        while j < len(mapparts):
            mpj = mapparts[j]
            # Different scaffolds
            if mpi[2] != mpj[2]:
                break
            
            # If j chromosome is real and chromosomes or cms don't match, skip
            if mpj[0] != 0 and (mpj[0] != mpi[0] or mpj[1] != mpi[1]):
                break
            
            # If chromosomes and cms match, fill intermediate blocks
            if mpj[0] == mpi[0] and mpj[1] == mpi[1]:
                for p in parts:
                    mapparts[p][0] = mpi[0]
                    mapparts[p][1] = mpi[1]
                break

            parts.append(j)
            j += 1
            
        i += 1


def write_new_gff(genes, genome, prefix):

    stats = {}
    stats['active'] = 0
    stats['haplotype'] = 0
    stats['removed'] = 0
    stats['overlapped'] = 0
    stats['broken'] = 0
    stats['total'] = 0
    for scaffold in genes:
        for gene in genes[scaffold]:
            stats['total'] += 1
            start, end = gene
            new_parts, haps = get_parts(scaffold, start, end, genome)
            
            if len(new_parts) == 1 and not haps:
                if new_parts[0][4] == 'removed':
                    stats['removed'] += 1
                else:
                    stats['active'] += 1
            elif not new_parts and len(haps) == 1:
                stats['haplotype'] += 1
            elif len(new_parts) == 1 and len(haps) == 1 and new_parts[0][0] == haps[0][0]:
                stats['overlapped'] += 1
            else:
                stats['broken'] += 1
    
    print('Active genes:\t{:>5}\t{:5.2f} %'.format(stats['active'], stats['active']/stats['total']*100))
    print('Haplo  genes:\t{:>5}\t{:5.2f} %'.format(stats['haplotype'], stats['haplotype']/stats['total']*100))
    print('Remove genes:\t{:>5}\t{:5.2f} %'.format(stats['removed'], stats['removed']/stats['total']*100))
    print('Ovlp   genes:\t{:>5}\t{:5.2f} %'.format(stats['overlapped'], stats['overlapped']/stats['total']*100))
    print('Broken genes:\t{:>5}\t{:5.2f} %'.format(stats['broken'], stats['broken']/stats['total']*100))
    print('Total  genes:\t{:>5}'.format(stats['total']))
    
def get_args():
    parser = argparse.ArgumentParser(description='''Output new database containing old linkage information on new HaploMerger output
    
        -m mergedgenome
        -g gff
        -d database
        -e errors
        -p prefix
        -o output
        ''')

    parser.add_argument('-m', '--mergedgenome', type=str, required=True)
    parser.add_argument('-g', '--gff', type=str, required=True)
    parser.add_argument('-d', '--database', type=str, required=True)
    parser.add_argument('-e', '--errors', type=str, required=False)
    parser.add_argument('-p', '--prefix', type=str, required=True)
    parser.add_argument('-o', '--output', type=str, required=True)
    return parser.parse_args()

if __name__ == '__main__':
    
    args = get_args()

    genome = load_genome(args.mergedgenome)
    
    linkage_map = load_linkage_map(args.database, args.errors, genome)
    write_new_map(linkage_map, genome, args.prefix, args.output)

    genes = load_gff(args.gff)
    write_new_gff(genes, genome, args.prefix)